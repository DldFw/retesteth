#include "TestBlock.h"

// Raw block RLP, that cann not be generated by retesteth
TestBlock::TestBlock(BYTES const& _rlp, string const& _chainName, FORK const& _chainNet, VALUE const& _number)
  : m_chainName(_chainName), m_doNotExport(false)
{
    m_blockNumber = spVALUE(_number.copy());
    m_chainNet = spFORK(new FORK(_chainNet.asString()));
    m_rawRLP = spBYTES(_rlp.copy());
}

DataObject TestBlock::asDataObject() const
{
    DataObject res;
    res["chainname"] = m_chainName;
    // res["chainnetwork"] = m_chainNet->asString();
    res["blocknumber"] = m_blockNumber->asDecString();
    if (!m_expectException.empty())
        res["expectException"] = m_expectException;

    // No test objects was registered
    if (!m_block.isEmpty())
    {
        res["uncleHeaders"] = DataObject(DataType::Array);
        for (auto const& un : m_block->uncles())
            res["uncleHeaders"].addArrayObject(un->asDataObject());
        res["blockHeader"] = m_block->header()->asDataObject();
        res["transactions"] = DataObject(DataType::Array);
        for (auto const& tr : m_block->transactions())
            res["transactions"].addArrayObject(tr->asDataObject(ExportOrder::OldStyle));

        for (auto const& trSequence : m_transactionExecOrder)
        {
            DataObject trInfo;
            BYTES const& b = std::get<0>(trSequence);
            string const& v = std::get<1>(trSequence);
            trInfo["rawBytes"] = b.asString();
            if (v.empty())
                trInfo["valid"] = "true";
            else
            {
                trInfo["valid"] = "false";
                trInfo["exception"] = v;
            }
            res["transactionSequence"].addArrayObject(trInfo);
        }
    }

    res["rlp"] = m_rawRLP->asString();
    return res;
}
